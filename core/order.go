package core

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/ont-bizsuite/ddxf-api-sdk"
	io "github.com/ont-bizsuite/ddxf-api-sdk/pkg/io/token"
	iotoken "github.com/ont-bizsuite/ddxf-api-sdk/pkg/io/token"
	ontSdk "github.com/ontio/ontology-go-sdk"
	"github.com/ontio/ontology/common/log"
	"github.com/ontio/oscore/aksk"
	"github.com/ontio/oscore/common"
	"github.com/ontio/oscore/core/http"
	"github.com/ontio/oscore/dao"
	"github.com/ontio/oscore/models/tables"
	"github.com/ontio/oscore/oscoreconfig"
	"github.com/ontio/oscore/utils"
	"math/big"
	"net/url"
	"strconv"
	"strings"
	"sync"
	"time"
)

type AliPayGenArg struct {
	App         int    `json:"app"`
	NotifyUrl   string `json:"notify_url"` //for alipay callback when pay
	OutTradeNo  string `json:"out_trade_no"`
	ReturnUrl   string `json:"return_url"` //for alipay return address when pay
	Subject     string `json:"subject"`
	TotalAmount string `json:"total_amount"`
}

type AliPayGenReturn struct {
	Code    int    `json:"code"`
	Message string `json:"msg"`
	Url     string `json:"url"`
}

type OscoreOrder struct {
	qrCodeCache  *sync.Map //qrCodeId -> QrCode
	DBUpdateLock *sync.Mutex
}

func NewOscoreOrder() *OscoreOrder {
	return &OscoreOrder{
		qrCodeCache:  new(sync.Map),
		DBUpdateLock: new(sync.Mutex),
	}
}

func BuildWetherForcastTransaction(user *ontSdk.Account, apiTokenTemplateId string, envTokenTemplateId string, agentHexAddress string) (string, string, error) {
	var ddxfAPIServer string
	var ontologyApiAddr string
	switch oscoreconfig.DefOscoreConfig.NetWorkId {
	case oscoreconfig.NETWORK_ID_MAIN_NET:
		ddxfAPIServer = oscoreconfig.DefOscoreConfig.DDXFAPIServer
		ontologyApiAddr = "http://dappnode1.ont.io:20336"
	case oscoreconfig.NETWORK_ID_POLARIS_NET:
		ddxfAPIServer = oscoreconfig.DefOscoreConfig.DDXFAPIServer
		ontologyApiAddr = "http://polaris2.ont.io:20336"
	default:
		return "", "", fmt.Errorf("BuildWetherForcastTransaction N.0 not suuport net type")
	}

	log.Debugf("BuildWetherForcastTransaction Y.0 apiTokenTemplateId:%s envTokenTemplateId:%s agent: %s", apiTokenTemplateId, envTokenTemplateId, agentHexAddress)

	tokenContract := ""
	tokenSdk := sdk.NewTokenSdk(ddxfAPIServer, ontologyApiAddr, tokenContract)

	seller := oscoreconfig.DefOscoreConfig.OscoreAccount
	txHash0, envTokenId, err := tokenSdk.GenerateToken(
		seller,
		iotoken.GenerateTokenInput{
			// template id, generated by /ddxf/dtoken/create_template
			TokenTemplateID: envTokenTemplateId,
			// to account
			To: user.Address.ToHexString(),
			// amount of token
			N: 1,
		})

	if err != nil {
		log.Errorf("BuildWetherForcastTransaction N.1 ", err)
		return "", "", err
	}

	log.Infof("BuildWetherForcastTransaction Y.1 GenerateTxHash %s: envTokenId: %s", txHash0, envTokenId)

	txHash1, apiTokenId, err := tokenSdk.GenerateToken(
		seller,
		iotoken.GenerateTokenInput{
			// template id, generated by /ddxf/dtoken/create_template
			TokenTemplateID: apiTokenTemplateId,
			// to account
			To: user.Address.ToHexString(),
			// amount of token
			N: 1,
		})

	if err != nil {
		log.Errorf("BuildWetherForcastTransaction N.2 ", err)
		return "", "", err
	}
	log.Infof("BuildWetherForcastTransaction Y.2 GenerateTxHash %s: apiTokenId : %s", txHash1, apiTokenId)

	argUse := io.UseTokenInput{
		Address: user.Address.ToHexString(),
		TokenID: envTokenId,
		N:       1,
	}
	useOut, err := tokenSdk.UseToken(user, argUse)
	if err != nil {
		log.Errorf("BuildWetherForcastTransaction N.3 ", err)
		return "", "", err
	}
	log.Infof("BuildWetherForcastTransaction Y.3 UseToken txHash : %s", useOut.Tx)

	argAgent := io.SetTokenAgentInput{
		Owner:   user.Address.ToHexString(),
		TokenID: apiTokenId,
		N:       []int{1},
		Agents:  []string{agentHexAddress},
	}
	txHash, err := tokenSdk.SetTokenAgent(user, argAgent)
	if err != nil {
		log.Errorf("BuildWetherForcastTransaction N.4 ", err)
		return "", "", err
	}
	log.Debugf("BuildWetherForcastTransaction Y.4 SetTokenAgent: %s", txHash)
	return txHash, apiTokenId, nil
}

type AliPayTradeQueryResponse struct {
	AliPayTradeQuery struct {
		BuyerPayAmount string `json:"buyer_pay_amount"`
		BuyerUserId    string `json:"buyer_user_id"`
		SendPayDate    string `json:"send_pay_date"`
		TotalAmount    string `json:"total_amount"`
		TradeNo        string `json:"trade_no"`
		TradeStatus    string `json:"trade_status"`
	} `json:"alipay_trade_query_response"`
	Sign string `json:"sign"`
}

func (this *OscoreOrder) QueryAliPayResult(orderId string, ontId string) (int32, error) {
	order, err := dao.DefOscoreApiDB.QueryOrderByOrderId(nil, orderId)
	if err != nil {
		log.Errorf("QueryAliPaySatusN.0 orderId: %s, %s", orderId, err)
		return 0, err
	}

	if order.State == tables.ORDER_STATE_PAYING || order.State == tables.ORDER_STATE_CANCEL {
		target := oscoreconfig.DefOscoreConfig.AliQueryAddress + "/alipay/raw?app=3&out_trade_no=" + order.OrderId
		res, _, err := http.DefClient.GetWithHeader(target, nil)
		if err != nil {
			log.Errorf("QueryAliPaySatus N.1 %s", err)
			return 0, err
		}

		respm := &AliPayTradeQueryResponse{}
		err = json.Unmarshal(res, &respm)
		if err != nil {
			log.Errorf("QueryAliPaySatus N.2 %s", err)
			return 0, err
		}

		if respm.AliPayTradeQuery.TradeStatus == TRADE_SUCCESS {
			callBackArg := &AliPayCallBackArg{
				OutTradeNo: order.OrderId,
				Status:     respm.AliPayTradeQuery.TradeStatus,
			}
			err = SendTxAliCore(callBackArg)
			if err != nil {
				log.Errorf("QueryAliPaySatus N.3 %s", err)
				return 0, err
			}
		}
	}

	order, err = dao.DefOscoreApiDB.QueryOrderByOrderId(nil, orderId)
	if err != nil {
		log.Errorf("QueryAliPaySatusN.4 orderId: %s, %s", orderId, err)
		return 0, err
	}

	return order.State, nil
}

func (this *OscoreOrder) RequestAliPay(orderId string, ontId string) (string, error) {
	var target string
	var b []byte
	var err error
	order, err := dao.DefOscoreApiDB.QueryOrderByOrderId(nil, orderId)
	if err != nil {
		log.Debugf("RequestAliPay N.0 %s", err)
		return "", err
	}

	if ontId != order.OntId {
		log.Errorf("RequestAliPay N.0.0 RequestAliPay N.0.0 ontId not match")
		return "", fmt.Errorf("RequestAliPay N.0.0 ontId not match")
	}

	amount := utils.ToIntByPrecise(order.Amount, oscoreconfig.ONG_DECIMALS)
	if amount.Cmp(big.NewInt(0)) == 0 {
		return "", fmt.Errorf("RequestAliPay order is free")
	}

	switch order.State {
	case tables.ORDER_STATE_WAIT_PAYMENT:
		req := &AliPayGenArg{
			App:         0,
			NotifyUrl:   oscoreconfig.DefOscoreConfig.QrCodeCallback,
			OutTradeNo:  order.OrderId,
			ReturnUrl:   oscoreconfig.DefOscoreConfig.AliRetrunHost + "/buyorder/" + order.OrderType + "/return/" + order.OrderId,
			Subject:     "oscore api payment",
			TotalAmount: order.Amount,
		}

		b, err = json.Marshal(req)
		if err != nil {
			log.Debugf("RequestAliPay N.1 %s", err)
			return "", err
		}
		target = oscoreconfig.DefOscoreConfig.AliPayAddress + "/aksk/alipay/gen"
	case tables.ORDER_STATE_PAYING:
		req := struct {
			App        int    `json:"app"`
			OutTradeNo string `json:"out_trade_no"`
		}{App: 0, OutTradeNo: order.OrderId}
		b, err = json.Marshal(req)
		if err != nil {
			log.Debugf("RequestAliPay N.2 %s", err)
			return "", err
		}

		target = oscoreconfig.DefOscoreConfig.AliPayAddress + "/aksk/alipay/refresh"
	default:
		return "", fmt.Errorf("can not request alipay when not int order state paying or wait paying")
	}

	ru, err := url.Parse(target)
	if err != nil {
		log.Debugf("RequestAliPay N.3 %s", err)
		return "", err
	}
	respb, err := aksk.Post(ru, b)
	if err != nil {
		log.Debugf("RequestAliPay N.4 %s", err)
		return "", err
	}
	var resp AliPayGenReturn
	err = json.Unmarshal(respb, &resp)
	if err != nil {
		log.Debugf("RequestAliPay N.5 %s", err)
		return "", err
	}

	if resp.Code != 0 {
		log.Debugf("RequestAliPay N.6 %s", err)
		return "", fmt.Errorf("%s", resp.Message)
	}

	err = dao.DefOscoreApiDB.UpdateTxInfoByOrderId(nil, order.OrderId, order.Result, tables.ORDER_STATE_PAYING, 0)
	if err != nil {
		log.Debugf("RequestAliPay N.7 %s", err)
		return "", fmt.Errorf("%s", err)
	}

	return resp.Url, nil
}

func (this *OscoreOrder) RenewOrder(param *common.RenewOrderParam, ontId string) (*string, error) {
	log.Debugf("RenewOrder %v\n", *param)
	order, err := dao.DefOscoreApiDB.QueryOrderByOrderId(nil, param.OrderId)
	if err != nil {
		log.Debugf("RenewOrder N.0 : %s", err)
		return nil, err
	}

	if order.OrderType != oscoreconfig.Api {
		log.Debugf("RenewOrder N.1 : %s", "not api type")
		return nil, errors.New("error order type. should be api type.")
	}

	if order.OntId != ontId {
		log.Debugf("RenewOrder N.2 : %s", "ontid mot match")
		return nil, errors.New("ontId do not match.")
	}

	_, err = dao.DefOscoreApiDB.QueryApiBasicInfoByApiId(nil, order.ApiId, tables.API_STATE_BUILTIN)
	if err != nil {
		return nil, fmt.Errorf("RenewOrder N.2.0. api already undercarriage. %s", err)
	}

	spec, err := dao.DefOscoreApiDB.QuerySpecificationsById(nil, param.SpecificationsId)
	if err != nil {
		log.Debugf("RenewOrder N.3 : %s", err)
		return nil, err
	}

	arr := strings.Split(ontId, ":")
	if len(arr) < 3 {
		log.Debugf("RenewOrder. N.4 : %s", "ontId err")
		return nil, errors.New("ontId err")
	}

	// now orer only coherent to apikey. but not usedNum.
	key, err := dao.DefOscoreApiDB.QueryApiKeyByApiKey(nil, order.ApiKey)
	if err != nil {
		log.Debugf("RenewOrder N.5 : %s", err)
		return nil, err
	}

	var amountStr string

	switch spec.SpecType {
	case tables.SPEC_TYPE_COUNT:
		if key.ApiKeyType == tables.API_KEY_TYPE_DURATION {
			return nil, fmt.Errorf("can not renew count spec on duration apikey.")
		}

		price := utils.ToIntByPrecise(spec.Price, oscoreconfig.ONG_DECIMALS)
		specifications := new(big.Int).SetUint64(uint64(spec.Amount))
		amount := new(big.Int).Mul(price, specifications)
		amountStr = utils.ToStringByPrecise(amount, oscoreconfig.ONG_DECIMALS)
	case tables.SPEC_TYPE_DURATION:
		if key.ApiKeyType == tables.API_KEY_TYPE_COUNT {
			return nil, fmt.Errorf("can not renew duration spec on count apikey.")
		}
		amountStr = spec.Price
	default:
		return nil, fmt.Errorf("error spec type %d", spec.SpecType)
	}

	tx, errl := dao.DefOscoreApiDB.DB.Beginx()
	if errl != nil {
		log.Debugf("RenewOrder. 6 : %s", err)
		return nil, errl
	}

	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	newOrderId := common.GenerateUUId(common.UUID_TYPE_ORDER_ID)
	order.OrderId = newOrderId
	order.Amount = amountStr
	order.SpecificationsId = param.SpecificationsId
	order.OrderKind = tables.ORDER_KIND_API_RENEW
	order.OrderTime = time.Now().Unix()
	order.Price = spec.Price
	order.Request = key.ApiKey

	err = dao.DefOscoreApiDB.InsertOrder(tx, order)
	if err != nil {
		errl = err
		log.Debugf("RenewOrder. 7 : %s", err)
		return nil, err
	}

	err = dao.DefOscoreApiDB.UpdateTxInfoByOrderId(tx, order.OrderId, order.Result, tables.ORDER_STATE_WAIT_PAYMENT, 0)
	if err != nil {
		errl = err
		log.Debugf("RenewOrder. 7.0 : %s", err)
		return nil, err
	}

	amount := utils.ToIntByPrecise(order.Amount, oscoreconfig.ONG_DECIMALS)
	if amount.Cmp(big.NewInt(0)) == 0 {
		log.Debugf("RenewOrder catch free spec")
		errl = CoreOrderCallBackHandle(order, tx)
		if errl != nil {
			return nil, errl
		}
	}

	err = tx.Commit()
	if err != nil {
		log.Debugf("RenewOrder. 10 : %s", err)
		errl = err
		return nil, err
	}

	return &order.OrderId, nil
}

func (this *OscoreOrder) TakeWetherForcastApiOrder(param *common.WetherForcastRequest, ontId string, userId string) (*string, error) {
	log.Debugf("%v", *param)
	data, err := json.Marshal(param)
	if err != nil {
		return nil, err
	}
	log.Debugf("%s", string(data))

	toolbox, err := dao.DefOscoreApiDB.QueryToolBoxById(nil, uint32(param.ToolBoxId))
	if err != nil {
		log.Debugf("TakeWetherForcastApiOrder. 0 : %s", err)
		return nil, err
	}
	api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiId(nil, param.ApiSourceId, tables.API_STATE_BUILTIN)
	if err != nil {
		log.Debugf("TakeWetherForcastApiOrder. 1 : %s", err)
		return nil, err
	}
	if api.ApiType != toolbox.Title || api.ApiKind != tables.API_KIND_DATA_PROCESS {
		log.Debugf("TakeWetherForcastApiOrder. 2 : %s", err)
		return nil, errors.New("wrong api type or kind")
	}

	// to do check the conrespond.
	alg, err := dao.DefOscoreApiDB.QueryAlgorithmById(nil, param.AlgorithmId)
	if err != nil {
		log.Debugf("TakeWethe2ForcastApiOrder. 3 : %s", err)
		return nil, err
	}
	env, err := dao.DefOscoreApiDB.QueryEnvById(nil, param.EnvId)
	if err != nil {
		log.Debugf("TakeWethe2ForcastApiOrder. 4 : %s", err)
		return nil, err
	}

	tx, errl := dao.DefOscoreApiDB.DB.Beginx()
	if errl != nil {
		log.Debugf("TakeWethe2ForcastApiOrder. 4 : %s", err)
		return nil, errl
	}

	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	apiprice := utils.ToIntByPrecise(api.Price, oscoreconfig.ONG_DECIMALS)
	algprice := utils.ToIntByPrecise(alg.Price, oscoreconfig.ONG_DECIMALS)
	envprice := utils.ToIntByPrecise(env.Price, oscoreconfig.ONG_DECIMALS)
	t0 := big.NewInt(0)
	t1 := t0.Add(apiprice, algprice)
	t2 := big.NewInt(0)
	allAmount := t2.Add(t1, envprice)
	amountStr := utils.ToStringByPrecise(allAmount, oscoreconfig.ONG_DECIMALS)

	orderId := common.GenerateUUId(common.UUID_TYPE_ORDER_ID)
	order := &tables.Order{
		OrderId:   orderId,
		ApiId:     api.ApiId,
		ToolBoxId: toolbox.Id,
		Title:     toolbox.Title,
		OrderType: oscoreconfig.ApiProcess,
		OrderTime: time.Now().Unix(),
		State:     tables.ORDER_STATE_WAIT_PAYMENT,
		OntId:     ontId,
		UserId:    userId,
		Amount:    amountStr,
		Price:     amountStr,
		OrderKind: tables.ORDER_KIND_DATA_PROCESS_WETHER,
		Request:   string(data), // leave it empty fill later.
	}
	log.Debugf("Request: %s", order.Request)

	err = dao.DefOscoreApiDB.InsertOrder(tx, order)
	if err != nil {
		errl = err
		return nil, err
	}
	err = dao.DefOscoreApiDB.UpdateTxInfoByOrderId(tx, order.OrderId, order.Result, tables.ORDER_STATE_WAIT_PAYMENT, 0)
	if err != nil {
		errl = err
		log.Debugf("TakeWethe2ForcastApiOrder. 5 : %s", err)
		return nil, err
	}

	amount := utils.ToIntByPrecise(order.Amount, oscoreconfig.ONG_DECIMALS)
	if amount.Cmp(big.NewInt(0)) == 0 {
		errl = CoreOrderCallBackHandle(order, tx)
		if errl != nil {
			return nil, errl
		}
	}

	err = tx.Commit()
	if err != nil {
		errl = err
		return nil, err
	}

	return &order.OrderId, nil
}

func (this *OscoreOrder) TakeOrder(param *common.TakeOrderParam, userId string, takeOrderWay int32) (*string, error) {
	tx, errl := dao.DefOscoreApiDB.DB.Beginx()
	if errl != nil {
		return nil, errl
	}

	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	info, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiId(tx, param.ApiId, tables.API_STATE_BUILTIN)
	if err != nil {
		errl = err
		log.Debugf("Take Order N.0 %s", err)
		return nil, err
	}

	spec, err := dao.DefOscoreApiDB.QuerySpecificationsById(tx, param.SpecificationsId)
	if err != nil {
		errl = err
		log.Debugf("Take Order N.1 %s", err)
		return nil, err
	}

	if spec.ApiId != info.ApiId {
		return nil, fmt.Errorf("spec.ApiId should be equal api.ApiId")
	}

	var amountStr string

	switch spec.SpecType {
	case tables.SPEC_TYPE_COUNT:
		price := utils.ToIntByPrecise(spec.Price, oscoreconfig.ONG_DECIMALS)
		specifications := new(big.Int).SetUint64(uint64(spec.Amount))
		amount := new(big.Int).Mul(price, specifications)
		amountStr = utils.ToStringByPrecise(amount, oscoreconfig.ONG_DECIMALS)
	case tables.SPEC_TYPE_DURATION:
		amountStr = spec.Price
	default:
		return nil, fmt.Errorf("error spec type %d", spec.SpecType)
	}

	orderId := common.GenerateUUId(common.UUID_TYPE_ORDER_ID)
	order := &tables.Order{
		OrderId:          orderId,
		Title:            info.Title,
		ProductName:      param.ProductName,
		OrderType:        oscoreconfig.Api,
		OrderTime:        time.Now().Unix(),
		State:            tables.ORDER_STATE_WAIT_PAYMENT,
		Amount:           amountStr,
		OntId:            param.OntId,
		UserId:           userId,
		UserName:         "", // do not save UserName get from tbl_user.
		Price:            spec.Price,
		ApiId:            info.ApiId,
		ApiUrl:           info.ApiUrl,
		SpecificationsId: param.SpecificationsId,
		OrderKind:        tables.ORDER_KIND_API,
	}

	err = dao.DefOscoreApiDB.InsertOrder(tx, order)
	if err != nil {
		errl = err
		return nil, err
	}

	err = dao.DefOscoreApiDB.UpdateTxInfoByOrderId(tx, order.OrderId, order.Result, tables.ORDER_STATE_WAIT_PAYMENT, 0)
	if err != nil {
		errl = err
		log.Debugf("TakeOrder. 0 : %s", err)
		return nil, err
	}

	amount := utils.ToIntByPrecise(order.Amount, oscoreconfig.ONG_DECIMALS)
	if takeOrderWay == tables.TAKE_ORDER_ADMIN || amount.Cmp(big.NewInt(0)) == 0 {
		log.Infof("TakeOrder catch free spec. or admin")
		errl = CoreOrderCallBackHandle(order, tx)
		if errl != nil {
			return nil, errl
		}
	}

	err = tx.Commit()
	if err != nil {
		errl = err
		return nil, err
	}

	return &order.OrderId, nil
}

func (this *OscoreOrder) QueryOrderByPage(pageNum, pageSize int, ontid string) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}
	total, err := dao.DefOscoreApiDB.QueryOrderSum(nil, ontid, oscoreconfig.Api)
	if err != nil {
		return nil, err
	}

	log.Debugf("QueryOrderByPage.Y 0 %d pageNum: %d pageSize: %d", total, pageNum, pageSize)
	start := (pageNum - 1) * pageSize
	orders, err := dao.DefOscoreApiDB.QueryOrderByPage(nil, start, pageSize, ontid, oscoreconfig.Api)
	if err != nil {
		log.Debugf("QueryOrderByPage.N 0 %d", err)
		return nil, err
	}
	log.Debugf("QueryOrderByPage order len.Y 1: %d", len(orders))
	res := make([]*common.OrderResult, 0)
	for _, order := range orders {
		log.Debugf("QueryOrderByPage %v", order)
		var apiKey *tables.APIKey
		spec, err := dao.DefOscoreApiDB.QuerySpecificationsById(nil, order.SpecificationsId)
		if err != nil {
			log.Debugf("QueryOrderByPage order len.N 1: %s", err)
			return nil, err
		}

		if order.ApiKey != "" {
			apiKey, err = dao.DefOscoreApiDB.QueryApiKeyByApiKey(nil, order.ApiKey)
			if err != nil && !dao.IsErrNoRows(err) {
				log.Debugf("QueryOrderByPage : N.1.0 %s", err)
				return nil, err
			}
		}

		if apiKey == nil {
			apiKey = &tables.APIKey{
				ApiKey:       "",
				OrderId:      order.OrderId,
				ApiId:        order.ApiId,
				RequestLimit: spec.Amount,
				UsedNum:      0,
			}
		}

		Comment, err := dao.DefOscoreApiDB.QueryOrderApiCommentByOrderId(nil, order.OrderId)
		if err != nil && !dao.IsErrNoRows(err) {
			log.Debugf("QueryOrderByPage order len.N 2: %s", err)
			return nil, err
		}

		api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiId(nil, order.ApiId, tables.API_STATE_IGNOR)
		if err != nil {
			log.Debugf("QueryOrderByPage order len.N 2.3: %s", err)
			return nil, err
		}

		specs, err := dao.DefOscoreApiDB.QuerySpecificationsByApiIdSpecType(nil, order.ApiId, spec.SpecType)
		if err != nil {
			log.Debugf("QueryOrderByPage order len.N 3: %s", err)
			return nil, err
		}

		res = append(res, &common.OrderResult{
			Title:          order.Title,
			OrderId:        order.OrderId,
			Amount:         order.Amount,
			CreateTime:     order.OrderTime,
			PayTime:        order.PayTime,
			ApiId:          order.ApiId,
			ApiUrl:         order.ApiUrl,
			State:          order.State,
			ApiKey:         order.ApiKey,
			Price:          order.Price,
			TxHash:         order.TxHash,
			Type:           order.OrderType,
			ApiState:       api.ApiState,
			RequestLimit:   apiKey.RequestLimit,
			UsedNum:        apiKey.UsedNum,
			Spec:           spec,
			Specifications: specs,
			Comment:        Comment,
		})
	}

	return map[string]interface{}{
		"total":     total,
		"orderList": res,
	}, nil
}

func (this *OscoreOrder) QueryDataProcessOrderByPage(pageNum, pageSize int, ontid string) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}
	total, err := dao.DefOscoreApiDB.QueryOrderSum(nil, ontid, oscoreconfig.ApiProcess)
	if err != nil {
		return nil, err
	}

	log.Debugf("QueryDataProcessOrderByPage.Y 0 %d", total)
	start := (pageNum - 1) * pageSize
	orders, err := dao.DefOscoreApiDB.QueryOrderByPage(nil, start, pageSize, ontid, oscoreconfig.ApiProcess)
	if err != nil {
		log.Debugf("QueryOrderByPage.N 0 %d", err)
		return nil, err
	}
	log.Debugf("QueryDataProcessOrderByPage order len.Y 1: %d", len(orders))
	res := make([]*common.DataProcessOrderResult, 0)
	for _, order := range orders {
		log.Debugf("QueryDataProcessOrderByPage %v", order)
		// todo handle WetherForcast api and data process.
		Comment, err := dao.DefOscoreApiDB.QueryOrderApiCommentByOrderId(nil, order.OrderId)
		if err != nil && !dao.IsErrNoRows(err) {
			return nil, err
		}

		res = append(res, &common.DataProcessOrderResult{
			Title:     order.Title,
			OrderId:   order.OrderId,
			OrderTime: order.OrderTime,
			PayTime:   order.PayTime,
			ApiId:     order.ApiId,
			State:     order.State,
			Price:     order.Price,
			TxHash:    order.TxHash,
			OrderKind: order.OrderKind,
			Request:   order.Request,
			Result:    order.Result,
			Type:      order.OrderType,
			Comment:   Comment,
		})
	}
	return map[string]interface{}{
		"total":     total,
		"orderList": res,
	}, nil
}

func (this *OscoreOrder) QueryDataProcessResultByPage(pageNum, pageSize int, ontid string) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}
	total, err := dao.DefOscoreApiDB.QueryOrderSumStatus(nil, ontid, oscoreconfig.ApiProcess, tables.ORDER_STATE_COMPLETE)
	if err != nil {
		return nil, err
	}

	log.Debugf("QueryDataProcessOrderByPage.Y 0 %d", total)
	start := (pageNum - 1) * pageSize
	orders, err := dao.DefOscoreApiDB.QueryOrderResultByPage(nil, start, pageSize, ontid, oscoreconfig.ApiProcess, tables.ORDER_STATE_COMPLETE)
	if err != nil {
		log.Debugf("QueryOrderByPage.N 0 %d", err)
		return nil, err
	}
	log.Debugf("QueryDataProcessOrderByPage order len.Y 1: %d", len(orders))
	res := make([]*common.DataProcessOrderResult, 0)
	for _, order := range orders {
		log.Debugf("QueryDataProcessOrderByPage %v", order)
		// todo handle WetherForcast api and data process.
		Comment, err := dao.DefOscoreApiDB.QueryOrderApiCommentByOrderId(nil, order.OrderId)
		if err != nil && !dao.IsErrNoRows(err) {
			return nil, err
		}

		toolbox, err := dao.DefOscoreApiDB.QueryToolBoxById(nil, order.ToolBoxId)
		if err != nil {
			return nil, err
		}

		res = append(res, &common.DataProcessOrderResult{
			Title:     order.Title,
			OrderId:   order.OrderId,
			OrderTime: order.OrderTime,
			PayTime:   order.PayTime,
			ApiId:     order.ApiId,
			State:     order.State,
			Price:     order.Price,
			TxHash:    order.TxHash,
			OrderKind: order.OrderKind,
			Request:   order.Request,
			Result:    order.Result,
			Type:      order.OrderType,
			Icon:      toolbox.Icon,
			Comment:   Comment,
		})
	}
	return map[string]interface{}{
		"total":     total,
		"orderList": res,
	}, nil
}

func (this *OscoreOrder) GetApiOrderList(param *common.OrderListRequest, ontId string) (map[string]interface{}, error) {
	var pageNum int
	var pageSize int
	var total int
	var err error
	orderlist := make([]*tables.Order, 0)
	if param.PageNum < 1 {
		pageNum = 1
	} else {
		pageNum = param.PageNum
	}
	if param.PageSize < 0 {
		pageSize = 0
	} else {
		pageSize = param.PageSize
	}
	start := (pageNum - 1) * pageSize
	log.Debugf("GetApiOrderList: pageNum: %d pageSize: %d param %v", pageNum, pageSize, *param)

	if param.Title == "" && param.ApiId == 0 {
		orderlist, total, err = dao.DefOscoreApiDB.QueryOrderByPageOntIdType(nil, start, pageSize, oscoreconfig.Api, ontId, param.Sorting)
		if err != nil {
			log.Debugf("GetApiOrderList.N 0 %s", err)
			return nil, err
		}
	} else if param.ApiId != 0 {
		orderlist, total, err = dao.DefOscoreApiDB.QueryOrderByPageOntIdTypeApiId(nil, start, pageSize, oscoreconfig.Api, ontId, param.ApiId, param.Sorting)
		if err != nil {
			log.Debugf("GetApiOrderList.N 1 %s", err)
			return nil, err
		}
	} else {
		log.Debugf("QueryOrderByPageOntIdTypeTitle: start: %d, pageSize: %d, ontId: %s, Title: %s, param.Sorting: %s", start, pageSize, ontId, param.Title, param.Sorting)
		orderlist, total, err = dao.DefOscoreApiDB.QueryOrderByPageOntIdTypeTitle(nil, start, pageSize, oscoreconfig.Api, ontId, param.Title, param.Sorting)
		if err != nil {
			log.Debugf("GetApiOrderList.N 2 %s", err)
			return nil, err
		}
	}

	orderResp := make([]*common.OrderResultResponse, 0)

	log.Debugf("GetApiOrderList: Y. 0 %d", len(orderlist))
	for _, order := range orderlist {
		apiKey, err := dao.DefOscoreApiDB.QueryApiKeyByApiKey(nil, order.ApiKey)
		if err != nil && !dao.IsErrNoRows(err) {
			log.Debugf("GetApiOrderList: N. 3 %s", err)
			return nil, err
		}
		if apiKey == nil {
			spec, err := dao.DefOscoreApiDB.QuerySpecificationsById(nil, order.SpecificationsId)
			if err != nil {
				log.Debugf("GetApiOrderList: N. 4 %s", err)
				return nil, err
			}
			apiKey = &tables.APIKey{
				ApiKey:       "",
				OrderId:      order.OrderId,
				ApiId:        order.ApiId,
				RequestLimit: spec.Amount,
				UsedNum:      0,
			}
		}

		user, err := dao.DefOscoreApiDB.QueryUserNameByOntId(nil, order.OntId)
		if err != nil {
			log.Debugf("GetApiOrderList: %s", err)
			return nil, err
		}

		order.UserName = user.UserName.String

		resp := &common.OrderResultResponse{
			Order:  order,
			ApiKey: apiKey,
		}
		orderResp = append(orderResp, resp)
	}

	totalIcome := big.NewInt(0)
	for _, order := range orderlist {
		amount := utils.ToIntByPrecise(order.Amount, oscoreconfig.ONG_DECIMALS)
		totalIcome = totalIcome.Add(totalIcome, amount)
	}
	amountStr := utils.ToStringByPrecise(totalIcome, oscoreconfig.ONG_DECIMALS)
	return map[string]interface{}{
		"coin":       "ONG",
		"total":      total,
		"orderList":  orderResp,
		"totalIcome": amountStr,
	}, nil
}

func (this *OscoreOrder) CommentOrderApi(param *common.CommentOrderApiRequest, ontId string) error {
	order, err := dao.DefOscoreApiDB.QueryOrderByOrderId(nil, param.OrderId)
	if err != nil {
		return err
	}
	comment := &tables.OrderApiComment{
		OrderId:     order.OrderId,
		ApiId:       order.ApiId,
		ToolBoxId:   order.ToolBoxId,
		StarNum:     param.StarNum,
		Comments:    param.Comments,
		OntId:       order.OntId,
		CommentTime: time.Now().Unix(),
	}

	tx, errl := dao.DefOscoreApiDB.DB.Beginx()
	if errl != nil {
		log.Debugf("CommentOrderApi.0. %s", errl)
		return errl
	}

	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	err = dao.DefOscoreApiDB.InsertOrderApiCommentByOrderId(tx, comment)

	// Evalute the score of OntId.
	if order.ApiId != 0 {
		api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiIdInState(tx, order.ApiId, []int32{tables.API_STATE_BUILTIN, tables.API_STATE_DISABLE_ORDER})
		if err != nil {
			errl = err
			log.Debugf("CommentOrderApi.N.0 %s", err)
			return err
		}

		this.DBUpdateLock.Lock()
		defer this.DBUpdateLock.Unlock()

		score, err := dao.DefOscoreApiDB.QueryOntScoreByOntId(tx, api.OntId)
		if err != nil && !dao.IsErrNoRows(err) {
			log.Debugf("CommentOrderApi.N.1 %s", err)
			return err
		} else if dao.IsErrNoRows(err) {
			fscore := &tables.OntIdScore{
				OntId:           api.OntId,
				TotalCommentNum: 1,
				TotalScore:      uint64(comment.StarNum),
			}
			err = dao.DefOscoreApiDB.InsertOntScore(tx, fscore)
			if err != nil {
				errl = err
				log.Debugf("CommentOrderApi.N.2 %s", err)
				return err
			}
		} else {
			score.TotalCommentNum += 1
			score.TotalScore += uint64(comment.StarNum)
			err = dao.DefOscoreApiDB.UpdateOntIdScore(tx, score)
			if err != nil {
				errl = err
				log.Debugf("CommentOrderApi.N.3 %s", err)
				return err
			}
		}
	}

	err = tx.Commit()
	if err != nil {
		errl = err
		return err
	}

	return err
}

func (this *OscoreOrder) DelCommentOrderByID(param *common.DelCommentOrderRequest, ontId string) error {
	tx, errl := dao.DefOscoreApiDB.DB.Beginx()
	if errl != nil {
		log.Debugf("DelCommentOrderByID.0. %s", errl)
		return errl
	}

	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	comment, err := dao.DefOscoreApiDB.QueryCommentById(tx, param.Id)
	if err != nil {
		errl = err
		log.Debugf("DelCommentOrderByID.0.1. %s", errl)
		return err
	}

	err = dao.DefOscoreApiDB.DelOrderApiCommentByOrderId(tx, param.Id, ontId)
	if err != nil {
		errl = err
		log.Debugf("DelCommentOrderByID.1. %s", errl)
		return err
	}

	if comment.ApiId != 0 {
		api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiIdInState(tx, comment.ApiId, []int32{tables.API_STATE_BUILTIN, tables.API_STATE_DISABLE_ORDER})
		if err != nil {
			errl = err
			log.Debugf("CommentOrderApi.N.0 %s", err)
			return err
		}

		this.DBUpdateLock.Lock()
		defer this.DBUpdateLock.Unlock()

		score, err := dao.DefOscoreApiDB.QueryOntScoreByOntId(tx, api.OntId)
		if err != nil {
			errl = err
			log.Debugf("DelCommentOrderByID.2. %s", errl)
			return err
		}

		if score.TotalCommentNum < 1 || score.TotalScore < uint64(comment.StarNum) {
			errl = fmt.Errorf("DelCommentOrderByID.2.0 err score. score.OntId: %s, score.TotalScore: %d, score.TotalCommentNum %d", score.OntId, score.TotalScore, score.TotalCommentNum)
			log.Debugf("%s", errl)
			return errl
		}
		score.TotalCommentNum -= 1
		score.TotalScore -= uint64(comment.StarNum)

		err = dao.DefOscoreApiDB.UpdateOntIdScore(tx, score)
		if err != nil {
			errl = err
			log.Debugf("DelCommentOrderByID.3. %s", errl)
			return err
		}
	}

	err = tx.Commit()
	if err != nil {
		errl = err
		log.Debugf("DelCommentOrderByID.3. %s", errl)
		return err
	}

	return nil
}

func (this *OscoreOrder) GetCommentsByApiId(pageNum, pageSize int, apiId uint32) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}

	start := (pageNum - 1) * pageSize

	cmts, total, err := dao.DefOscoreApiDB.QueryOrderApiCommentByApiId(nil, start, pageSize, apiId)
	if err != nil {
		return nil, err
	}

	res := map[string]interface{}{
		"total":     total,
		"orderList": cmts,
	}
	return res, nil
}

func (this *OscoreOrder) GetCommentsByToolBoxId(pageNum, pageSize int, toolBoxId uint32) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}

	start := (pageNum - 1) * pageSize

	cmts, total, err := dao.DefOscoreApiDB.QueryOrderApiCommentByToolBoxId(nil, start, pageSize, toolBoxId)
	if err != nil {
		return nil, err
	}

	res := map[string]interface{}{
		"total":     total,
		"orderList": cmts,
	}
	return res, nil
}

func (this *OscoreOrder) GetCommentPage(pageNum, pageSize int) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}
	start := (pageNum - 1) * pageSize
	cmts, total, err := dao.DefOscoreApiDB.QueryCommentPage(nil, start, pageSize)
	if err != nil {
		return nil, err
	}

	res := map[string]interface{}{
		"total":     total,
		"orderList": cmts,
	}
	return res, nil
}

func (this *OscoreOrder) GetCommentsById(commentId uint32) (*common.CommentDetail, error) {
	log.Debugf("GetCommentsById: Y.0 %d", commentId)
	cmt, err := dao.DefOscoreApiDB.QueryCommentById(nil, commentId)
	if err != nil {
		log.Errorf("DB 0 %s", err)
		return nil, err
	}

	log.Debugf("GetCommentsById: Y.1 %d", cmt.ApiId)
	api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiIdInState(nil, cmt.ApiId, []int32{tables.API_STATE_BUILTIN, tables.API_STATE_DISABLE_ORDER})
	if err != nil {
		log.Errorf("DB 1 %s", err)
		return nil, err
	}

	detail := &common.CommentDetail{
		*cmt,
		api.Title,
	}

	return detail, nil
}

func (this *OscoreOrder) DelCommentsById(commentId uint32) error {
	tx, errl := dao.DefOscoreApiDB.DB.Beginx()
	if errl != nil {
		log.Debugf("DelCommentsById.0. %s", errl)
		return errl
	}

	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	comment, err := dao.DefOscoreApiDB.QueryCommentById(tx, commentId)
	if err != nil {
		errl = err
		log.Debugf("DelCommentsById.0.1. %s", errl)
		return err
	}

	err = dao.DefOscoreApiDB.DelCommentById(tx, commentId)
	if err != nil {
		errl = err
		log.Debugf("DelCommentsById.0.2. %s", errl)
		return err
	}

	if comment.ApiId != 0 {
		api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiIdInState(tx, comment.ApiId, []int32{tables.API_STATE_BUILTIN, tables.API_STATE_DISABLE_ORDER})
		if err != nil {
			errl = err
			log.Debugf("DelCommentsById.N.0 %s", err)
			return err
		}

		score, err := dao.DefOscoreApiDB.QueryOntScoreByOntId(tx, api.OntId)
		if err != nil {
			errl = err
			log.Debugf("DelCommentsById.N.1. %s", errl)
			return err
		}

		if score.TotalCommentNum < 1 || score.TotalScore < uint64(comment.StarNum) {
			errl = fmt.Errorf("DelCommentsById.N.2 err score. score.OntId: %s, score.TotalScore: %d, score.TotalCommentNum %d", score.OntId, score.TotalScore, score.TotalCommentNum)
			log.Debugf("%s", errl)
			return errl
		}
		score.TotalCommentNum -= 1
		score.TotalScore -= uint64(comment.StarNum)

		err = dao.DefOscoreApiDB.UpdateOntIdScore(tx, score)
		if err != nil {
			errl = err
			log.Debugf("DelCommentsById.N. 3. %s", errl)
			return err
		}
	}

	err = tx.Commit()
	if err != nil {
		errl = err
		log.Debugf("DelCommentsById.N.3. %s", errl)
		return err
	}

	return nil
}

func (this *OscoreOrder) GetOrderDetailById(orderId string) (interface{}, error) {
	order, err := dao.DefOscoreApiDB.QueryOrderByOrderId(nil, orderId)
	if err != nil {
		return nil, err
	}

	info, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiId(nil, order.ApiId, tables.API_STATE_IGNOR)
	if err != nil {
		log.Errorf("GetOrderDetailById N.0.0 %s", err)
		return nil, err
	}

	switch order.OrderKind {
	case tables.ORDER_KIND_DATA_PROCESS_WETHER:
		paramWether := &common.WetherForcastRequest{}
		err = json.Unmarshal([]byte(order.Request), paramWether)
		if err != nil {
			log.Debugf("GetOrderDetailById.N.0: %s", err)
			return nil, err
		}
		toolbox, err := dao.DefOscoreApiDB.QueryToolBoxById(nil, uint32(paramWether.ToolBoxId))
		if err != nil {
			log.Debugf("TakeWetherForcastApiOrder. 0 : %s", err)
			return nil, err
		}
		env, err := dao.DefOscoreApiDB.QueryEnvById(nil, paramWether.EnvId)
		if err != nil {
			log.Debugf("GetOrderDetailById.N.1: %s", err)
			return nil, err
		}
		alg, err := dao.DefOscoreApiDB.QueryAlgorithmById(nil, paramWether.AlgorithmId)
		if err != nil {
			log.Debugf("GetOrderDetailById.N.2: %s", err)
			return nil, err
		}
		api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiId(nil, order.ApiId, tables.API_STATE_BUILTIN)
		if err != nil {
			log.Debugf("TakeWetherForcastApiOrder. 1 : %s", err)
			return nil, err
		}

		detail := common.WetherOrderDetail{
			TargetDate: paramWether.TargetDate,
			Location:   &paramWether.Location,
			ToolBox:    toolbox,
			ApiSource:  api,
			Algorithm:  alg,
			Env:        env,
			Result:     order.Result,
			State:      order.State,
		}
		return &common.OrderDetailResponse{
			Res: detail,
		}, nil
	case tables.ORDER_KIND_API, tables.ORDER_KIND_API_RENEW:
		spec, err := dao.DefOscoreApiDB.QuerySpecificationsById(nil, order.SpecificationsId)
		if err != nil {
			log.Debugf("QueryOrderByPage order len.N 1: %s", err)
			return nil, err
		}

		res := &common.OrderResult{
			Title:      order.Title,
			OrderId:    order.OrderId,
			Amount:     order.Amount,
			CreateTime: order.OrderTime,
			PayTime:    order.PayTime,
			ApiId:      order.ApiId,
			ApiUrl:     order.ApiUrl,
			State:      order.State,
			ApiKey:     order.ApiKey,
			Price:      order.Price,
			TxHash:     order.TxHash,
			Type:       order.OrderType,
			ApiState:   info.ApiState,
			Spec:       spec,
		}
		return res, nil
	default:
		return nil, fmt.Errorf("wrong order kind %d", order.OrderKind)
	}
}

//1. delete qrCodeId
//2. cancel order
func (this *OscoreOrder) CancelOrder(orderId string) error {
	tx, err := dao.DefOscoreApiDB.DB.Beginx()
	if err != nil {
		return err
	}

	var errl error
	defer func() {
		if errl != nil {
			tx.Rollback()
		}
	}()

	state, err := dao.DefOscoreApiDB.QueryOrderStatusByOrderId(tx, orderId)
	if err != nil {
		errl = err
		return err
	}

	if state != tables.ORDER_STATE_WAIT_PAYMENT && state != tables.ORDER_STATE_PAYING {
		errl = fmt.Errorf("Canceled Order: can not cancelOrder not in state paying.")
		return errl
	}

	err = dao.DefOscoreApiDB.UpdateOrderStatus(tx, orderId, tables.ORDER_STATE_CANCEL)
	if err != nil {
		errl = err
		return err
	}

	errl = tx.Commit()
	return errl
}

func (this *OscoreOrder) GetTxResult(orderId string) (*common.GetOrderResponse, error) {
	order, err := dao.DefOscoreApiDB.QueryOrderByOrderId(nil, orderId)
	if err != nil {
		return nil, err
	}
	res := &common.GetOrderResponse{
		UserName: order.UserName,
		OntId:    order.OntId,
	}
	res.Result = strconv.Itoa(int(order.State))
	return res, nil
}

func (this *OscoreOrder) QueryApiKeyByPage(pageNum, pageSize int, ontId string) (map[string]interface{}, error) {
	if pageNum < 1 {
		pageNum = 1
	}
	if pageSize < 0 {
		pageSize = 0
	}
	start := (pageNum - 1) * pageSize
	total, err := dao.DefOscoreApiDB.QueryApiKeyCountByOntId(nil, ontId)
	if err != nil {
		log.Debugf("QueryApiKeyByPage N.0 %s", err)
		return nil, err
	}

	keys, err := dao.DefOscoreApiDB.QueryApiKeyByOntId(nil, ontId, start, pageSize)
	if err != nil {
		log.Debugf("QueryApiKeyByPage N.1 %s", err)
		return nil, err
	}

	res := make([]*common.ApiKeysDetail, 0)
	var specType int32
	for _, apiKey := range keys {
		var willInvalid bool
		switch apiKey.ApiKeyType {
		case tables.API_KEY_TYPE_COUNT:
			if apiKey.UsedNum != 0 && ((apiKey.RequestLimit <= apiKey.UsedNum) || ((apiKey.RequestLimit - apiKey.UsedNum) <= (apiKey.RequestLimit / 10))) {
				willInvalid = true
			}

			specType = tables.SPEC_TYPE_COUNT
		case tables.API_KEY_TYPE_DURATION:
			checkDate := time.Now().AddDate(0, 0, 7).Unix()
			if checkDate > apiKey.OutDate {
				willInvalid = true
			}
			specType = tables.SPEC_TYPE_DURATION
		default:
			return nil, fmt.Errorf("error spec type %d", apiKey.ApiKeyType)
		}

		specs, err := dao.DefOscoreApiDB.QuerySpecificationsByApiIdSpecType(nil, apiKey.ApiId, specType)
		if err != nil {
			log.Debugf("QueryApiKeyByPage N.2 %s", err)
			return nil, err
		}

		api, err := dao.DefOscoreApiDB.QueryApiBasicInfoByApiIdInState(nil, apiKey.ApiId, []int32{tables.API_STATE_BUILTIN, tables.API_STATE_DISABLE_ORDER, tables.API_STATE_DELETE})
		if err != nil {
			log.Debugf("QueryApiKeyByPage N.3 %s", err)
			return nil, err
		}

		if api.ApiState != tables.API_STATE_DELETE {
			kd := &common.ApiKeysDetail{
				*apiKey,
				willInvalid,
				api.Icon,
				api.Title,
				specType,
				api.ApiState,
				specs,
			}
			res = append(res, kd)
		} else {
			total = total - 1
		}
	}

	return map[string]interface{}{
		"total":     total,
		"orderList": res,
	}, nil
}
