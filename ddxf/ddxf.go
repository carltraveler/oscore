package ddxf

import (
	"github.com/ont-bizsuite/ddxf-api-sdk"
	//"github.com/ontio/ontology-crypto/signature"
	io "github.com/ont-bizsuite/ddxf-api-sdk/pkg/io/datameta"
	iometa "github.com/ont-bizsuite/ddxf-api-sdk/pkg/io/meta"
	iotoken "github.com/ont-bizsuite/ddxf-api-sdk/pkg/io/token"
	"github.com/ontio/ontology/common/log"
	"github.com/zhiqiangxu/ddxf"
	//ontology_go_sdk "github.com/ontio/ontology-go-sdk"
	"fmt"
	"github.com/ontio/oscore/models/tables"
	"github.com/ontio/oscore/oscoreconfig"
)

func BuyerRecordDDXF(apiKey *tables.APIKey) (string, error) {
	var ddxfAPIServer string
	var ontologyApiAddr string
	switch oscoreconfig.DefOscoreConfig.NetWorkId {
	case oscoreconfig.NETWORK_ID_MAIN_NET:
		ddxfAPIServer = oscoreconfig.DefOscoreConfig.DDXFAPIServer
		ontologyApiAddr = "http://dappnode1.ont.io:20336"
	case oscoreconfig.NETWORK_ID_POLARIS_NET:
		ddxfAPIServer = oscoreconfig.DefOscoreConfig.DDXFAPIServer
		ontologyApiAddr = "http://polaris2.ont.io:20336"
	default:
		return "", fmt.Errorf("not suuport net type")
	}
	seller := oscoreconfig.DefOscoreConfig.OscoreAccount

	dataMeta := map[string]interface{}{
		"OrderId":       apiKey.OrderId,
		"UserId":        apiKey.UserId,
		"ApiKeyType":    apiKey.ApiKeyType,
		"OutDate":       apiKey.OutDate,
		"RequestLimit ": apiKey.RequestLimit,
		"ApiId":         apiKey.ApiId,
	}

	dataMetaHash, err := ddxf.HashObject2Hex(dataMeta)
	if err != nil {
		log.Errorf("BuyerRecordDDXF N.0 %s", err)
		return "", err
	}

	metaInput := iometa.CreateMetaInput{
		OntIDs:   []string{"did:ont:" + seller.Address.ToBase58(), apiKey.OntId},
		Meta:     dataMeta,
		MetaHash: dataMetaHash,
	}

	metaSdk := sdk.NewMetaSdk(ddxfAPIServer)
	_, err = metaSdk.CreateMeta(seller, metaInput)
	if err != nil {
		log.Errorf("BuyerRecordDDXF CreateMeta Failed first %s", err)
		return "", err
	}

	tokenMeta := map[string]interface{}{
		"read":  true,
		"write": true,
	}

	tokenMetaHash, _ := ddxf.HashObject2Hex(tokenMeta)

	metaTokenInput := iometa.CreateMetaInput{
		OntIDs:   []string{"did:ont:" + seller.Address.ToBase58(), apiKey.OntId},
		Meta:     tokenMeta,
		MetaHash: tokenMetaHash,
	}

	_, err = metaSdk.CreateMeta(seller, metaTokenInput)
	if err != nil {
		log.Errorf("BuyerRecordDDXF CreateMeta Failed first %s", err)
		return "", err
	}

	dataSdk := sdk.NewDataMetaSdk(ddxfAPIServer, ontologyApiAddr)

	dataID, err := dataSdk.CreateDataMeta(seller, io.CreateDataMetaInput{
		// data fingerprint
		Fingerprint: "dataHash",
		// data meta id
		DataMetaHash: dataMetaHash,
	})
	if err != nil {
		log.Errorf("BuyerRecordDDXF CreateDataMeta N.1 %s", err)
		return "", err
	}
	log.Infof("BuyerRecordDDXF Y.1 CreateDataMeta dataID: %s, mataHash: %s", dataID, dataMetaHash)

	// will have a default token contract.
	tokenContract := ""
	tokenSdk := sdk.NewTokenSdk(ddxfAPIServer, ontologyApiAddr, tokenContract)

	tokenTemplateId, err := tokenSdk.CreateTokenTemplate(
		seller,
		iotoken.CreateTokenTemplateInput{
			// template info
			Template: iotoken.TokenTemplate{
				// data id is generated by /ddxf/data_meta/create
				DataID: dataID,
				// token meta hash for token meta
				TokenMetaHash: tokenMetaHash,
			},
		})

	if err != nil {
		log.Errorf("BuyerRecordDDXF CreateTokenTemplate N.2 %s", err)
		return "", err
	}
	log.Infof("BuyerRecordDDXF Y.2 CreateTokenTemplate %s: dataID: %s", tokenTemplateId, dataID)

	txHash, tokenId, err := tokenSdk.GenerateToken(
		seller,
		iotoken.GenerateTokenInput{
			// template id, generated by /ddxf/dtoken/create_template
			TokenTemplateID: tokenTemplateId,
			// to account
			To: seller.Address.ToHexString(),
			// amount of token
			N: 1,
		})

	if err != nil {
		log.Errorf("BuyerRecordDDXF GenerateToken N.3 %s", err)
		return "", err
	}
	log.Infof("BuyerRecordDDXF Y.3 GenerateToken txHash %s: dataID: %s", txHash, tokenId)

	return txHash, nil
}
